<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <title>Ng∆∞·ªùi Nh·∫≠n - Nh·∫≠n file b·∫£o m·∫≠t</title>
  <!-- Tailwind CSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <!-- Th√™m CryptoJS cho DES3 v√† c√°c h√†m bƒÉm kh√°c -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
  <style>
    body {
      font-family: 'Inter', sans-serif;
      background-color: #f0f2f5; /* Light grey background */
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      margin: 0;
    }
    .fb-container {
      background-color: #fff;
      padding: 2rem; /* p-8 */
      border-radius: 1.5rem; /* rounded-3xl */
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.1); /* shadow-xl */
      max-width: 32rem; /* max-w-lg */
      width: 100%;
      text-align: center;
      border: 1px solid #e2e8f0; /* Subtle border */
    }
    .fb-header {
      font-size: 2.25rem; /* text-4xl */
      font-weight: 700; /* font-bold */
      color: #4f46e5; /* Deep purple */
      margin-bottom: 2rem; /* mb-8 */
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .fb-header::before {
      content: 'üéß'; /* Audio icon */
      margin-right: 12px;
      font-size: 1.2em;
    }
    .fb-key-input {
      width: 100%;
      padding: 0.75rem; /* p-3 */
      margin-bottom: 1.5rem; /* mb-6 */
      border-width: 1px; /* border */
      border-color: #d1d5db; /* border-gray-300 */
      border-radius: 0.5rem; /* rounded-lg */
      outline: none; /* focus:outline-none */
      box-shadow: 0 0 0 2px rgba(99, 102, 241, 0); /* focus:ring-2 focus:ring-indigo-500 (initially transparent) */
      transition: box-shadow 0.2s ease-in-out; /* Add transition for focus ring */
      color: #374151; /* text-gray-700 */
      font-size: 0.875rem; /* text-sm */
      min-height: 120px; /* More height for keys */
      resize: vertical; /* Allow vertical resizing */
      background-color: #f8fafc; /* bg-gray-50 for readonly */
      cursor: default; /* Indicate it's readonly */
    }
    .fb-key-input:focus {
      border-color: #6366f1; /* focus:border-indigo-500 */
      box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.5); /* focus:ring-2 focus:ring-indigo-500 */
    }
    .fb-button {
      width: 100%;
      padding-left: 1.5rem; /* px-6 */
      padding-right: 1.5rem; /* px-6 */
      padding-top: 0.75rem; /* py-3 */
      padding-bottom: 0.75rem; /* py-3 */
      background-image: linear-gradient(to right, #6366f1, #9333ea); /* bg-gradient-to-r from-indigo-500 to-purple-600 */
      color: #fff; /* text-white */
      font-weight: 700; /* font-bold */
      border-radius: 9999px; /* rounded-full */
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* shadow-lg */
      outline: none; /* focus:outline-none */
      transition-property: all; /* transition */
      transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); /* ease-in-out */
      transition-duration: 300ms; /* duration-300 */
      transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y)); /* transform */
      letter-spacing: 0.05em; /* Slightly more space for button text */
      cursor: pointer; /* Ensure cursor is pointer */
    }
    .fb-button:hover:not(:disabled) { /* Apply hover only if not disabled */
      background-image: linear-gradient(to right, #4f46e5, #7e22ce); /* hover:from-indigo-600 hover:to-purple-700 */
      transform: translateY(-4px); /* hover:-translate-y-1 */
    }
    .fb-button:focus {
      box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.5), 0 0 0 4px rgba(99, 102, 241, 0.25); /* focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-75 */
    }
    .fb-button:disabled { /* Styling for disabled button */
        opacity: 0.6;
        cursor: not-allowed;
        background-image: linear-gradient(to right, #9ca3af, #6b7280); /* Grey out when disabled */
        transform: none; /* No transform when disabled */
        box-shadow: none; /* No shadow when disabled */
    }
    .fb-status {
      margin-top: 1.5rem; /* mt-6 */
      font-size: 1.125rem; /* text-lg */
      font-weight: 500; /* font-medium */
      color: #374151; /* text-gray-700 */
    }
    .fb-label {
        display: block;
        text-align: left;
        color: #374151; /* text-gray-700 */
        font-size: 0.875rem; /* text-sm */
        font-weight: 700; /* font-bold */
        margin-bottom: 0.5rem; /* mb-2 */
    }
  </style>
</head>
<body>
  <div class="fb-container">
    <h1 class="fb-header">Ng∆∞·ªùi Nh·∫≠n</h1>

    <label class="fb-label" for="senderKey">Kh√≥a c√¥ng khai ng∆∞·ªùi g·ª≠i (PEM):</label>
    <textarea id="senderKey" rows="6" class="fb-key-input" readonly placeholder="Kh√≥a c√¥ng khai c·ªßa ng∆∞·ªùi g·ª≠i s·∫Ω xu·∫•t hi·ªán ·ªü ƒë√¢y..."></textarea>
    <button id="confirmKeyBtn" class="fb-button" disabled>X√°c nh·∫≠n kh√≥a</button>

    <p id="status" class="fb-status">Ch∆∞a k·∫øt n·ªëi server.</p>

    <div id="downloadSection" style="display:none;">
      <a id="downloadLink" href="#" class="fb-button" download="received_recording.mp3">üì• T·∫£i file ƒë√£ gi·∫£i m√£</a>
    </div>
  </div>

  <!-- ƒê√£ di chuy·ªÉn to√†n b·ªô kh·ªëi script xu·ªëng cu·ªëi body v√† b·ªçc trong DOMContentLoaded -->
  <script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script> <!-- Ensure this is here -->
  <script>
    document.addEventListener('DOMContentLoaded', (event) => {
      const socket = io();
      const statusDiv = document.getElementById('status');
      const confirmKeyBtn = document.getElementById('confirmKeyBtn');
      const senderKeyTextarea = document.getElementById('senderKey');
      const downloadSection = document.getElementById('downloadSection');
      const downloadLink = document.getElementById('downloadLink');

      let senderPublicKeyPem = '';
      let decryptedSessionKey = null; // ƒê√¢y s·∫Ω l√† kh√≥a phi√™n gi·∫£i m√£ ƒë∆∞·ª£c (Uint8Array)
      let receivedChunks = [];
      let fileMetadata = null;
      let totalChunksExpected = 3; // C√≥ th·ªÉ l·∫•y t·ª´ metadata n·∫øu ƒë∆∞·ª£c g·ª≠i

      // --- Helper functions ---
      function arrayBufferToBase64(buffer) {
          let binary = '';
          const bytes = new Uint8Array(buffer);
          const len = bytes.byteLength;
          for (let i = 0; i < len; i++) {
              binary += String.fromCharCode(bytes[i]);
          }
          return btoa(binary);
      }

      function base64ToUint8Array(base64) {
          return Uint8Array.from(atob(base64), c => c.charCodeAt(0));
      }
      
      function decryptDes3(data_base64, key_uint8array, iv_uint8array) {
          const keyHex = CryptoJS.enc.Hex.parse(Array.from(key_uint8array).map(b => b.toString(16).padStart(2, '0')).join(''));
          const ivHex = CryptoJS.enc.Hex.parse(Array.from(iv_uint8array).map(b => b.toString(16).padStart(2, '0')).join(''));
          const cipherParams = CryptoJS.lib.CipherParams.create({
              ciphertext: CryptoJS.enc.Base64.parse(data_base64)
          });

          const decrypted = CryptoJS.TripleDES.decrypt(
              cipherParams,
              keyHex,
              { iv: ivHex, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 }
          );
          const wordArray = decrypted;
          const resultBytes = [];
          for (let i = 0; i < wordArray.sigBytes; i++) {
              resultBytes.push((wordArray.words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff);
          }
          return new Uint8Array(resultBytes);
      }

      function calculateSha512(data_uint8array) {
          const wordArray = CryptoJS.lib.WordArray.create(data_uint8array);
          const hash = CryptoJS.SHA512(wordArray);
          const resultBytes = [];
          for (let i = 0; i < hash.sigBytes; i++) {
              resultBytes.push((hash.words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff);
          }
          return new Uint8Array(resultBytes);
      }

      function compareUint8Arrays(arr1, arr2) {
          if (arr1.length !== arr2.length) return false;
          for (let i = 0; i < arr1.length; i++) {
              if (arr1[i] !== arr2[i]) return false;
          }
          return true;
      }

      // TODO: Tri·ªÉn khai c√°c h√†m Web Crypto API cho RSA (import public key, verify signature)
      // C√°c h√†m n√†y v·∫´n c·∫ßn ƒë·ªÉ x√°c th·ª±c b·∫£o m·∫≠t th·ª±c t·∫ø c·ªßa metadata v√† c√°c chunk
      async function importPublicKey(pemKey) {
          console.warn("Ch·ª©c nƒÉng import public key RSA ch∆∞a ƒë∆∞·ª£c tri·ªÉn khai ho√†n ch·ªânh. C·∫ßn Web Crypto API.");
          return null;
      }

      async function verifyRsaSignature(publicKey, hashUint8Array, signatureUint8Array) {
          console.warn("Ch·ª©c nƒÉng x√°c minh ch·ªØ k√Ω RSA ch∆∞a ƒë∆∞·ª£c tri·ªÉn khai ho√†n ch·ªânh. C·∫ßn Web Crypto API.");
          return true;
      }
      // --- End Helper functions ---

      socket.on('connect', () => {
        statusDiv.innerText = 'üîó ƒê√£ k·∫øt n·ªëi server. B√°o ng∆∞·ªùi nh·∫≠n s·∫µn s√†ng...';
        socket.emit('receiver_ready'); // B√°o cho server bi·∫øt ng∆∞·ªùi nh·∫≠n s·∫µn s√†ng
      });

      socket.on('sender_public_key', (data) => {
        senderPublicKeyPem = data.key;
        senderKeyTextarea.value = senderPublicKeyPem;
        statusDiv.innerText = 'üîë ƒê√£ nh·∫≠n kh√≥a c√¥ng khai ng∆∞·ªùi g·ª≠i, vui l√≤ng x√°c nh·∫≠n.';
        confirmKeyBtn.disabled = false; // K√≠ch ho·∫°t n√∫t x√°c nh·∫≠n
      });

      confirmKeyBtn.onclick = () => {
        if (!senderPublicKeyPem) {
          alert("Ch∆∞a nh·∫≠n ƒë∆∞·ª£c kh√≥a c√¥ng khai ng∆∞·ªùi g·ª≠i.");
          return;
        }
        statusDiv.innerText = 'Ch·∫•p nh·∫≠n kh√≥a c√¥ng khai, ch·ªù nh·∫≠n file...';
        socket.emit('public_key_confirm', {status: 'ok'});

        confirmKeyBtn.disabled = true;
        senderKeyTextarea.style.display = 'none';
        confirmKeyBtn.style.display = 'none';
      };

      socket.on('meta', (data) => {
        statusDiv.innerText = 'üìÑ ƒê√£ nh·∫≠n metadata.';
        fileMetadata = data.meta;
        const signatureBase64 = data.signature;

        // TODO: X√°c minh ch·ªØ k√Ω metadata (c·∫ßn tri·ªÉn khai importPublicKey v√† verifyRsaSignature)
        console.log('Metadata:', fileMetadata);
        console.log('Metadata Signature (Base64):', signatureBase64);
      });

      // S·ª± ki·ªán m·ªõi: Nh·∫≠n kh√≥a phi√™n ƒë√£ ƒë∆∞·ª£c gi·∫£i m√£ t·ª´ server
      socket.on('decrypted_session_key', (data) => {
          statusDiv.innerText = 'üîì ƒê√£ nh·∫≠n kh√≥a phi√™n ƒë√£ gi·∫£i m√£ t·ª´ server.';
          decryptedSessionKey = base64ToUint8Array(data.key);
          console.log('Decrypted session key received:', decryptedSessionKey);
          if (decryptedSessionKey.length !== 24) {
              console.error("L·ªói: Kh√≥a phi√™n ƒë√£ gi·∫£i m√£ c√≥ ƒë·ªô d√†i kh√¥ng ƒë√∫ng (kh√¥ng ph·∫£i 24 byte)!");
              statusDiv.innerText = "L·ªói: Kh√≥a phi√™n kh√¥ng h·ª£p l·ªá.";
              socket.disconnect();
          }
      });

      socket.on('key', async (data) => {
        statusDiv.innerText = 'üîê ƒê√£ nh·∫≠n kh√≥a phi√™n m√£ h√≥a (d√†nh cho server ƒë·ªÉ gi·∫£i m√£).';
        console.log('Encrypted session key (base64) received for server:', data.enc_key);
      });

      socket.on('chunk', async (data) => {
        statusDiv.innerText = `üì¶ ƒêang nh·∫≠n ƒëo·∫°n ${data.index + 1}/${totalChunksExpected}...`;

        const index = data.index;
        const iv_base64 = data.iv;
        const cipher_base64 = data.cipher;
        const hash_base64 = data.hash;
        const sig_base64 = data.sig;

        const iv_uint8 = base64ToUint8Array(iv_base64);
        const cipher_uint8 = base64ToUint8Array(cipher_base64);
        const received_hash_uint8 = base64ToUint8Array(hash_base64);
        const sig_uint8 = base64ToUint8Array(sig_base64);

        // 1. Ki·ªÉm tra hash = SHA512(iv || cipher)
        const combinedData = new Uint8Array(iv_uint8.length + cipher_uint8.length);
        combinedData.set(iv_uint8, 0);
        combinedData.set(cipher_uint8, iv_uint8.length);
        const calculated_hash_uint8 = calculateSha512(combinedData);

        if (!compareUint8Arrays(calculated_hash_uint8, received_hash_uint8)) {
          console.error(`L·ªói Hash ƒëo·∫°n ${index}: Hash kh√¥ng kh·ªõp!`);
          statusDiv.innerText = `L·ªói: Hash ƒëo·∫°n ${index} kh√¥ng kh·ªõp!`;
          socket.disconnect();
          return;
        }
        console.log(`Hash ƒëo·∫°n ${index} H·ª¢P L·ªÜ.`);

        // 2. Verify ch·ªØ k√Ω sig v·ªõi hash v√† kh√≥a public ng∆∞·ªùi g·ª≠i (c·∫ßn tri·ªÉn khai verifyRsaSignature)
        // const senderPublicKeyObj = await importPublicKey(senderPublicKeyPem); 
        // const isValidChunkSig = await verifyRsaSignature(senderPublicKeyObj, received_hash_uint8, sig_uint8);
        // if (!isValidChunkSig) {
        //   console.error(`L·ªói Ch·ªØ k√Ω ƒëo·∫°n ${index}: Ch·ªØ k√Ω kh√¥ng h·ª£p l·ªá!`);
        //   statusDiv.innerText = `L·ªói: Ch·ªØ k√Ω ƒëo·∫°n ${index} kh√¥ng h·ª£p l·ªá!`;
        //   socket.disconnect();
        //   return;
        // }
        console.log(`Ch·ªØ k√Ω ƒëo·∫°n ${index} H·ª¢P L·ªÜ (Gi·∫£ ƒë·ªãnh, c·∫ßn x√°c minh).`);

        receivedChunks[index] = {
          index: index,
          iv: iv_uint8,
          cipher: cipher_base64 
        };

        console.log(`Nh·∫≠n ƒëo·∫°n ${index + 1}`, {iv_base64, cipher_base64, hash_base64, sig_base64});
      });

      socket.on('end', async () => {
        statusDiv.innerText = 'üéâ ƒê√£ nh·∫≠n xong to√†n b·ªô c√°c ƒëo·∫°n file! ƒêang gi·∫£i m√£...';

        // Ki·ªÉm tra xem kh√≥a phi√™n ƒë√£ gi·∫£i m√£ ƒë√£ c√≥ v√† h·ª£p l·ªá ch∆∞a
        if (!decryptedSessionKey || decryptedSessionKey.length !== 24) {
            console.error("L·ªói: Kh√≥a phi√™n ch∆∞a ƒë∆∞·ª£c gi·∫£i m√£ ho·∫∑c kh√¥ng h·ª£p l·ªá!");
            statusDiv.innerText = "L·ªói: Kh√≥a phi√™n kh√¥ng h·ª£p l·ªá. Kh√¥ng th·ªÉ gi·∫£i m√£.";
            return;
        }

        if (Object.keys(receivedChunks).length !== totalChunksExpected) {
            console.error(`L·ªói: S·ªë l∆∞·ª£ng ƒëo·∫°n nh·∫≠n ƒë∆∞·ª£c kh√¥ng ƒë·ªß (${Object.keys(receivedChunks).length}/${totalChunksExpected})!`);
            statusDiv.innerText = "L·ªói: Thi·∫øu c√°c ƒëo·∫°n file. Kh√¥ng th·ªÉ gi·∫£i m√£.";
            return;
        }

        const sortedChunks = Object.values(receivedChunks).sort((a, b) => a.index - b.index);

        let decryptedParts = [];
        for (let i = 0; i < sortedChunks.length; i++) {
          const chunk = sortedChunks[i];
          try {
              const decryptedPart = decryptDes3(chunk.cipher, decryptedSessionKey, chunk.iv);
              decryptedParts.push(decryptedPart);
              console.log(`ƒê√£ gi·∫£i m√£ ƒëo·∫°n ${i+1}.`);
          } catch (e) {
              console.error(`L·ªói khi gi·∫£i m√£ ƒëo·∫°n ${i+1}:`, e);
              statusDiv.innerText = `L·ªói khi gi·∫£i m√£ ƒëo·∫°n ${i+1}. Vui l√≤ng ki·ªÉm tra console.`;
              return;
          }
        }

        const finalBlob = new Blob(decryptedParts, { type: 'audio/mpeg' });
        const fileUrl = URL.createObjectURL(finalBlob);

        downloadLink.href = fileUrl;
        // C·∫£i ti·∫øn nh·ªè: ƒë·∫£m b·∫£o lu√¥n c√≥ t√™n file, ngay c·∫£ khi metadata kh√¥ng c√≥
        downloadLink.download = fileMetadata && fileMetadata.filename ? 
                                 `decoded_${fileMetadata.filename}` : 
                                 'decoded_audio.mp3';
        
        downloadSection.style.display = 'block';

        statusDiv.innerText = '‚úÖ ƒê√£ gi·∫£i m√£ file th√†nh c√¥ng! B·∫°n c√≥ th·ªÉ t·∫£i xu·ªëng.';
        console.log("File ƒë√£ s·∫µn s√†ng ƒë·ªÉ t·∫£i xu·ªëng.");
      });

      socket.on('send_cancel', (data) => {
          statusDiv.innerText = `‚ùå G·ª≠i file b·ªã h·ªßy: ${data.reason}`;
          console.error("G·ª≠i file b·ªã h·ªßy:", data.reason);
      });

      socket.on('disconnect', () => {
        statusDiv.innerText = 'üî¥ ƒê√£ ng·∫Øt k·∫øt n·ªëi.';
      });
    }); // End DOMContentLoaded listener
  </script>
</body>
</html>
